// fft.S: FFT function assembly source code

// Comment this in to switch from DIT to DIF. Note that the definition of this
// symbol should ideally be passed as a compiler/assembler option instead but
// this does not seem to be possible without manually modifying the Makefile
// generated by Xtensa Xplorer.

//#define DIF

#define LOG2_N_WAVE 10

.align 4
.global fft
.type fft, @function

fft:
  // a2 = fr, a3 = fi, a4 = m
  entry a1, 128

  // Verify that 5 <= m <= 10, implying that 32 <= n <= 1024.
  // The upper limit is already present in the reference implementation
  // and the lower limit is necessary because some processing steps of this
  // function load up to 16 complex values from memory per clock cycle and
  // process these in one-stage software pipelines.

  bgei a4, 5, m_valid
  movi.n a5, 11
  blt a4, a5, m_valid
  movi.n a2, -1
  retw
m_valid:

#ifdef DIF
  // save m because it is needed to determine the initial value of k
  mov.n a13, a4
#endif

  // a4 = n = 1 << m
  ssl a4
  movi.n a4, 1
  sll a4, a4

  // b0 = 0, b1 = 1, b2 = inverse, b3 = shift
  movi.n a6, 2
  wsr.BR a6
  beqz a5, no_inverse
  orb b2, b2, b1
no_inverse:

  // scale = 0
  movi.n a5, 0

/*--DECIMATION IN TIME-------------------------------------------------------*/

#ifndef DIF
  // a7 = forward counter, a8 = reverse counter
  { movi.n a7, 0; movi.n a8, 0; nop }
  // a9 = real load pointer, a10 = imaginary load pointer
  { mov.n a9, a2; mov.n a10, a3; nop }
  // a11 = real store pointer, a12 = imaginary store pointer
  { mov.n a11, a2; mov.n a12, a3; nop }
dit:
  { load1 a9; load2 a10; nop }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { store1 a11; store2 a12; bne a7, a4, dit }
#endif

/*--MAIN LOOP----------------------------------------------------------------*/

#ifdef DIF
  // a6 = l = n/2
  movi.n a6, 1
  ssr a6
  srl a6, a4
  // a7 = k = LOG2_N_WAVE - m
  neg a13, a13
  addi.n a7, a13, LOG2_N_WAVE
#else
  // a6 = l = 1
  movi.n a6, 1
  // a7 = k = LOG2_N_WAVE - 1
  movi.n a7, LOG2_N_WAVE - 1
#endif

main_loop:

#ifdef DIF
  beqz a6, main_loop_done // l == 0 ? => done
#else
  beq a4, a6, main_loop_done // l == n ? => done
#endif

  slli a8, a6, 1 // a8 = l*2

/*--SCALING------------------------------------------------------------------*/

  bf b2, no_scaling // skip scaling for non-inverse FFT
  { mov.n a9, a2; mov.n a10, a3; andb b3, b3, b0 } // b3 = shift = 0
  { load1 a9; load2 a10; movi.n a11, 8 }
check_scaling:
  // pass n to "scaling" so that the loop can be broken by setting a11 = n
  { load1 a9; load2 a10; scaling b3, a11, a4 }
  bne a11, a4, check_scaling
  scaling b3, a11, a4
  bf b3, scaling_done
  addi.n a5, a5, 1 // ++scale
  j scaling_done
no_scaling:
  orb b3, b3, b1 // shift = 1
scaling_done:

/*--BUTTERFLIES--------------------------------------------------------------*/

#ifdef DIF
  #define BFLY_MAIN bfly_dif_main
  #define BFLY_UNROLL1 bfly_dif_unroll1
  #define BFLY_UNROLL2 bfly_dif_unroll2
  #define BFLY_UNROLL4 bfly_dif_unroll4
#else
  #define BFLY_MAIN bfly_dit_main
  #define BFLY_UNROLL1 bfly_dit_unroll1
  #define BFLY_UNROLL2 bfly_dit_unroll2
  #define BFLY_UNROLL4 bfly_dit_unroll4
#endif

  { mov.n a9, a2; mov.n a10, a3; nop }
  { mov.n a11, a2; mov.n a12, a3; nop }

  // loop iterations for l in {1, 2, 4} are treated differently
  beqi a6, 1, bfly_unroll1
  beqi a6, 2, bfly_unroll2
  beqi a6, 4, bfly_unroll4

  movi.n a13, 0
bfly_outer:
  { offs_load3 a9, a8; offs_load4 a10, a8; movi.n a14, 0 }
  { load1 a9; load2 a10; beqi a6, 8, bfly_inner_done }
bfly_inner:
  { offs_load3 a9, a8; offs_load4 a10, a8; BFLY_MAIN a14, a7, b2, b3 }
  { load1 a9; load2 a10; addi a15, a14, 8 }
  { offs_store3 a11, a8; offs_store4 a12, a8; nop }
  { store1 a11; store2 a12; bne a6, a15, bfly_inner }
bfly_inner_done:
  BFLY_MAIN a14, a7, b2, b3
  { offs_store3 a11, a8; offs_store4 a12, a8; add.n a13, a13, a8 }
  { store1 a11; store2 a12; nop }
  { inc4 a9, a10, a11, a12, a8; nop; bne a4, a13, bfly_outer }
  j next_iter

bfly_unroll1:
  { load1 a9; load2 a10; movi.n a13, 16 }
  { load1 a9; load2 a10; BFLY_UNROLL1 b2, b3 }
bfly_unroll1_loop:
  { store1 a11; store2 a12; BFLY_UNROLL1 b2, b3 }
  { load1 a9; load2 a10; addi.n a13, a13, 16 }
  { store1 a11; store2 a12; BFLY_UNROLL1 b2, b3 }
  { load1 a9; load2 a10; bne a4, a13, bfly_unroll1_loop }
bfly_unroll1_final:
  { store1 a11; store2 a12; BFLY_UNROLL1 b2, b3 }
  { store1 a11; store2 a12; j next_iter }

bfly_unroll2:
  { load1 a9; load2 a10; movi.n a13, 16 }
  { load1 a9; load2 a10; BFLY_UNROLL2 b2, b3 }
bfly_unroll2_loop:
  { store1 a11; store2 a12; BFLY_UNROLL2 b2, b3 }
  { load1 a9; load2 a10; addi.n a13, a13, 16 }
  { store1 a11; store2 a12; BFLY_UNROLL2 b2, b3 }
  { load1 a9; load2 a10; bne a4, a13, bfly_unroll2_loop }
bfly_unroll2_final:
  { store1 a11; store2 a12; BFLY_UNROLL2 b2, b3 }
  { store1 a11; store2 a12; j next_iter }

bfly_unroll4:
  { load1 a9; load2 a10; movi.n a13, 16 }
  { load1 a9; load2 a10; BFLY_UNROLL4 b2, b3 }
bfly_unroll4_loop:
  { store1 a11; store2 a12; BFLY_UNROLL4 b2, b3 }
  { load1 a9; load2 a10; addi.n a13, a13, 16 }
  { store1 a11; store2 a12; BFLY_UNROLL4 b2, b3 }
  { load1 a9; load2 a10; bne a4, a13, bfly_unroll4_loop }
bfly_unroll4_final:
  { store1 a11; store2 a12; BFLY_UNROLL4 b2, b3 }
  { store1 a11; store2 a12; nop }

next_iter:
#ifdef DIF
  // l = l/2; ++k;
  movi.n a8, 1
  ssr a8
  { srl a6, a6; addi.n a7, a7, 1; j main_loop }
#else
  // l = l*2; --k;
  { mov.n a6, a8; addi.n a7, a7, -1; j main_loop }
#endif

/*--DECIMATION IN FREQUENCY--------------------------------------------------*/

main_loop_done:

#ifdef DIF
  // a7 = forward counter, a8 = reverse counter
  { movi.n a7, 0; movi.n a8, 0; nop }
  // a9 = real load pointer, a10 = imaginary load pointer
  { mov.n a9, a2; mov.n a10, a3; nop }
  // a11 = real store pointer, a12 = imaginary store pointer
  { mov.n a11, a2; mov.n a12, a3; nop }
dif:
  { load1 a9; load2 a10; nop }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { dswap11 a2, a7, a8; dswap12 a3, a7, a8; nop }
  { dswap21 a2, a7, a8; dswap22 a3, a7, a8; dinc a7, a8, a4 }
  { store1 a11; store2 a12; bne a4, a7, dif }
#endif

  mov.n a2, a5
  retw
